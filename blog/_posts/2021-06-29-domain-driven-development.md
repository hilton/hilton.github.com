---
title: Domain-driven development
description: Why no-code tools enable ultimate domain-driven design
layout: hh
tags: NoCode DDD
image: flags.jpg
---

![Correct use of flags on two boxes of US and UK power adaptors](flags.jpg)

<a class="unsplash" href="https://unsplash.com/photos/jUSu0686zDM" rel="noopener noreferrer"><span><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32"><title>unsplash-logo</title><path d="M20.8 18.1c0 2.7-2.2 4.8-4.8 4.8s-4.8-2.1-4.8-4.8c0-2.7 2.2-4.8 4.8-4.8 2.7.1 4.8 2.2 4.8 4.8zm11.2-7.4v14.9c0 2.3-1.9 4.3-4.3 4.3h-23.4c-2.4 0-4.3-1.9-4.3-4.3v-15c0-2.3 1.9-4.3 4.3-4.3h3.7l.8-2.3c.4-1.1 1.7-2 2.9-2h8.6c1.2 0 2.5.9 2.9 2l.8 2.4h3.7c2.4 0 4.3 1.9 4.3 4.3zm-8.6 7.5c0-4.1-3.3-7.5-7.5-7.5-4.1 0-7.5 3.4-7.5 7.5s3.3 7.5 7.5 7.5c4.2-.1 7.5-3.4 7.5-7.5z"></path></svg></span><span>freestocks</span></a>

A central difficulty in software development lies in getting everyone involved to understand and use the business domain concepts and language needed to build the software.
Meanwhile, no-code automation avoids this problem completely.

## Euro-English and domain language

Imagine building software with an international team that has evolved its own dialect of Euro-English that outsiders can’t understand.
In theory, you could constrain the software to use a standard English instead by adopting an English dictionary.
In a more extreme version of this thought experiment, coders might even use a programming language that 
[only uses English words in code](use-english-in-code).

Imagine a software development environment that checked naming against a set of word lists.
This would introduce a higher level of naming things, according to which dictionaries you choose.
For a base English dictionary, you might choose a comprehensive dictionary or the deliberately reduced [Basic English](https://en.wikipedia.org/wiki/Basic_English).
For the business domain, you might choose between commercial or open-source _supply chain management_ dictionaries, or develop your own.

Meanwhile, a team of native English speakers wouldn’t have to develop their own English dialect.
But they would still have the same kind of problem, because so software systems end up using so much jargon - the domain language.
Any software development team, regardless of native languages, needs a way to align on the words they use.
Because words matter.

## Domain-driven design

[Domain-Driven Design](https://martinfowler.com/bliki/DomainDrivenDesign.html)
promotes using domain language directly in the software implementation, so that you don’t have to map the business domain to different concepts in the code.
This greatly improves complex systems’ maintainability, especially in enterprise software development.

Domain-driven design deserves its popularity, but its benefits come at a cost.
Precisely defining and encapsulating the business domain in software requires learning, discipline and additional effort.
Developers will also need to maintain additional documentation, such as domain language glossaries.

Perhaps the most important part of domain-driven design involves learning its
[ubiquitous language](https://martinfowler.com/bliki/UbiquitousLanguage.html) -
the domain language - from the subject-matter experts who use it as a matter of course.
Learning to speak a new language requires a lot of effort, which goes some way towards explaining the famous difficulty of _naming things_.

## Domain-driven development

No-code tools exist to allow subject-matter experts to automate their own decisions and processes.
In the same way that a group of native English speakers naturally use standard language,
subject-matter matter experts using no-code automation naturally use domain concepts, structures, and language.

[No-code automation needs a better name](no-code-name)
because the absence of code doesn’t explain everything.
In particular, _no-code_ doesn’t have to mean _non-technical_, any more than spreadsheets shouldn’t support sophisticated formulas and functions.
Meanwhile, focusing on the absence of code or technical limitations distracts us from a more important capability.
No-code tools replace domain-driven design with inherently _domain-driven development_.
