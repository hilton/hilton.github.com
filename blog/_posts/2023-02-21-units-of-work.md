---
title: Units of work
description: Overthinking product development team task lists
layout: hh
tags: product
image: wet-paint.jpg
---

![](nesting-dolls.jpg)

[Simon Hurry](https://unsplash.com/photos/QtiZpH_N2sA){:.photocredit}

Product development organisations waste time organising,
especially when company growth leads to constant _reorganising_.
They organise two things: the people, and the work.

## Work structure

Product development teams typically structure their work into ‘units’ at various levels of granularity.
From smallest to largest, one unit of work could consist of one:

1. **code commit** - a source code version control history entry
2. **pull/merge request** - a batch of proposed code changes
3. **development task** - a change to the software
4. **user story** - a new or updated software product capability
5. **epic** - a set of related user stories
6. **key result** - a success criterion for an objective
7. **objective** - a high-level product development goal
8. **initiative/theme** - related work from one of the above levels.

In practice, this all varies between teams.

## Variations

Different teams use different names and descriptions for their units of work.
Other variations include:

* **method** - the levels used depends on the software/product development methods used
* **scope** - each unit may contain exactly one, a few, or many units from a previous level
* **timescale** - from minutes/hours, at the top of the list, to months/years at the bottom
* **assignment** - work may belong to a single team member, several, the whole team, or multiple teams.

In general, different variations make different teams successful.
And while the level of success varies, so does the level of chaos.
Deliberately or accidentally, product development teams have several ways to make their work more chaotic.

## Method complexity

Software and product development methods vary between teams, and their complexity tends to increase over time.
Not only does your product development organisation probably not need eight levels of units of work,
but it would do better by simplifying how it works by removing one or two.

But managers like to manage and plan, so long-term initiatives and themes tend to emerge.
And programmers just _love_ tidy hierarchical structures.

## Tooling proliferation

Additional chaos results from something worse than two many levels in this work breakdown:
manifesting every level you use as an artefact in some tool.
And when you don’t have a tool that maps the whole hierarchy then you get something worse:
several tools that capture 1-3 levels each.

These tools integrate awkwardly at best, with links to other tools that take to long to initially load.
And their costs typically lead to different subsets of the organisation having access to each tool, with the result that half of the links don’t even work for half of the people.

## Size variance

When some user stories require 5-8 times the tasks/effort to complete, for example, the work becomes difficult to keep track of.
Inconsistent scope and timescale within one level hinder visibility and management.
That creates a risk of attempts to add clarity by predicting the future.

## Prediction trap

Attempting to create ‘clarity’ with imposed estimation practices increases method complexity and doesn’t actually work.
Wild guessing has many consequences, but they don’t include increased clarity.

Instead, things that you actually know, such as the results of discovery work, get mixed up with dodgy predictions.
When you make predictions, you have to manage them, which means more meetings to explain how the predictions change as their wrongness matures.
